# CSVパース戦略と不完全なクォート処理

## 問題の分析

### 実際のCSV形式

実際のCSVファイルを確認したところ、以下の特徴がありました：

```csv
1,'154848',1,1,1,'     1',1200,'      3500',佐藤 花子',サトウ ハナコ',昭和35年5月10日','070-0034','0166-23-4567'
```

#### 観察された問題

1. **文字列フィールドはシングルクォート `'` で囲まれている**
   - 例: `'154848'`, `'     1'`, `'070-0034'`

2. **数値フィールドはクォートなし**
   - 例: `1`, `1200`, `3500`

3. **不完全なクォート**（最大の問題）
   - 末尾のみクォート: `佐藤 花子'` ← 開始クォートがない！
   - 末尾のみクォート: `サトウ ハナコ'` ← 開始クォートがない！
   - 末尾のみクォート: `昭和35年5月10日'` ← 開始クォートがない！

4. **正しいクォート**も混在
   - 例: `'154848'` ← 開始・終了両方ある

---

## 問題の原因

### なぜ不完全なクォートが発生するのか？

元のCSV生成システム（おそらくレセプトシステム）が：
- 一部のフィールドだけクォートで囲む
- クォートの開始を省略する場合がある
- 末尾のクォートだけ残る

これは**標準的なCSV形式ではない**ため、通常のCSVパーサーでは正しく処理できません。

---

## 解決策

### アプローチ1: Papa Parseの設定（現在の実装）

```javascript
const config = {
  quoteChar: "'",        // シングルクォートをクォート文字として認識
  escapeChar: "'",       // エスケープもシングルクォート
  delimiter: ',',
  // ...
};
```

**メリット**:
- 正しいクォート `'154848'` は正常にパース

**デメリット**:
- 不完全なクォート `佐藤 花子'` はパースエラーまたは不正なデータになる可能性

---

### アプローチ2: クリーニング関数で後処理（現在の実装）

```javascript
function cleanField(fieldValue) {
  if (!fieldValue) return '';

  let result = String(fieldValue);

  // すべてのクォート文字を削除（シングル、ダブル、バッククォート）
  result = result.replace(/['"`]/g, '');

  // 先頭・末尾の空白削除
  result = result.trim();

  return result;
}
```

**処理フロー**:
1. Papa Parseがパース（不完全なクォートはそのまま残る）
2. `cleanField()`がすべてのクォートを削除
3. 最終的にクリーンなデータになる

**メリット**:
- シンプル
- 不完全なクォートも正しいクォートもすべて削除される

**デメリット**:
- クォート内のカンマが含まれる場合、Papa Parseが誤ってフィールドを分割する可能性

---

### アプローチ3: 前処理で不完全なクォートを修正（推奨）

**戦略**: ファイル全体を読み込み、不完全なクォートを削除してからPapa Parseに渡す

```javascript
async function preprocessCSV(file) {
  const text = await file.text();

  // 不完全なクォートを修正
  // 1. 末尾だけのクォート（カンマの直前）を削除
  let cleaned = text.replace(/([^,'])'(?=,)/g, '$1');

  // 2. 末尾だけのクォート（行末）を削除
  cleaned = cleaned.replace(/([^,'])'$/gm, '$1');

  // 3. 行頭のクォート（開始クォートなし）を削除
  cleaned = cleaned.replace(/^'([^'])/gm, '$1');

  return new Blob([cleaned], { type: 'text/csv' });
}

// 使用例
export async function parseCSVFile(file, options = {}) {
  // 前処理
  const preprocessedFile = await preprocessCSV(file);

  // Papa Parseで処理
  return new Promise((resolve, reject) => {
    Papa.parse(preprocessedFile, {
      quoteChar: "'",
      // ...
    });
  });
}
```

**メリット**:
- 不完全なクォートを削除してから正規のパースを実行
- Papa Parseが正しいクォート `'154848'` を適切に処理
- クォート内のカンマも正しく処理される

**デメリット**:
- ファイル全体を読み込むため、大きいファイルでメモリを消費
- 正規表現が複雑になる可能性

---

## 現在の実装状態

### ✅ 実装済み

1. **Papa Parse設定**
   ```javascript
   quoteChar: "'"  // シングルクォート
   escapeChar: "'" // シングルクォート
   ```

2. **cleanField()でクォート削除**
   ```javascript
   result = result.replace(/['"`]/g, '');
   ```

3. **fixKana()でもクォート削除（ダブルチェック）**
   ```javascript
   result = result.replace(/['"`]/g, '');
   ```

### 🔄 処理フロー

```
CSVファイル（不完全なクォート含む）
  ↓
Papa Parse（quoteChar: "'"）
  - 正しいクォート: 正常処理
  - 不完全なクォート: そのまま残る
  ↓
cleanField()
  - replace(/['"`]/g, '') ← すべてのクォート削除
  ↓
fixKanaAndTrim()
  - fixKana() → replace(/['"`]/g, '') ← 再度クォート削除
  - trimSpaces() → 空白削除
  ↓
✅ クリーンなデータ
```

---

## テストケース

### 入力CSV

```csv
1,'154848',1,1,1,'     1',1200,'      3500',佐藤 花子',サトウ ハナコ',昭和35年5月10日','070-0034'
```

### 期待される出力

| フィールド | 入力 | cleanField後 | fixKana後 |
|-----------|------|-------------|----------|
| 1 | `1` | `1` | `1` |
| 2 | `'154848'` | `154848` | `154848` |
| 3-8 | (数値) | (数値) | (数値) |
| 9 | `佐藤 花子'` | `佐藤 花子` | `佐藤 花子` |
| 10 | `サトウ ハナコ'` | `サトウ ハナコ` | `サトウ ハナコ` |
| 11 | `昭和35年5月10日'` | `昭和35年5月10日` | `昭和35年5月10日` |
| 12 | `'070-0034'` | `070-0034` | `070-0034` |

---

## 問題が残る可能性のあるケース

### ケース1: クォート内にカンマが含まれる

**例**: `'旭川市1条通8丁目, 2階'` （住所にカンマ）

**問題**: Papa Parseがカンマでフィールドを分割してしまう可能性

**解決策**:
- 前処理アプローチ3を実装
- または、住所にカンマが含まれないことを前提とする

### ケース2: 不完全なクォートが先頭にある

**例**: `'佐藤 花子` （終了クォートがない）

**問題**: Papa Parseがパースエラーを出す可能性

**解決策**:
- `cleanField()`で削除されるため、大きな問題にはならない

---

## 推奨事項

### 短期的対策（現在の実装で十分）

現在の実装：
- Papa Parse設定: `quoteChar: "'"`
- `cleanField()`で全クォート削除
- `fixKana()`で再度クォート削除

**これで問題なく動作するはず**です。不完全なクォートはすべて削除されます。

### 長期的対策（将来の改善）

もし**クォート内のカンマ**が問題になる場合：

1. **前処理関数を実装**
   ```javascript
   async function preprocessCSV(file) {
     const text = await file.text();
     // 不完全なクォートを修正
     const cleaned = text.replace(/([^,'])'(?=,|$)/g, '$1');
     return new Blob([cleaned], { type: 'text/csv' });
   }
   ```

2. **より堅牢な正規表現**
   - 開始クォートなし、終了クォートありのパターンを特定
   - 正しいクォートはそのまま残す

---

## まとめ

### 現在の実装の強み

✅ **シンプル**: Papa Parse + cleanField() のシンプルな構成
✅ **堅牢**: すべてのクォートを削除するため、不完全なクォートの影響を受けない
✅ **二重チェック**: cleanField() → fixKana() で確実にクォート削除

### 想定される動作

```
入力: '154848',佐藤 花子','070-0034'
  ↓ Papa Parse
中間: ['154848', '佐藤 花子'', '070-0034']
  ↓ cleanField()
出力: ['154848', '佐藤 花子', '070-0034']
```

**結論**: 現在の実装で十分に不完全なクォートに対応できています！

---

**Document Version**: 1.0
**Last Updated**: 2025-02-15
**Author**: 関根 (sekine53629)
